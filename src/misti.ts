import { Runner, Args, UIProvider } from "@ton/blueprint";
import { runMistiCommand } from "@nowarp/misti/dist/cli";
import path from "path";
import fs from "fs";

export const STDLIB_PATH_ARG = "--tact-stdlib-path";

function argsToStringList(args: Args): string[] {
  const argsList: string[] = args._;
  Object.entries(args).forEach(([key, value]) => {
    if (key !== "_" && value !== undefined) {
      if (typeof value === "boolean") {
        argsList.push(key);
      } else {
        argsList.push(key, value.toString());
      }
    }
  });
  return argsList;
}

/**
 * Returns true if there is an explicitly specified path to the Tact stdlib in the list of arguments.
 */
function hasStdlibPath(args: string[]): boolean {
  return args.find((a) => a === STDLIB_PATH_ARG) !== undefined;
}

/**
 * Finds a directory which name starts from `prefix` inside `startPath`.
 */
function findDirectoryPath(
  startPath: string,
  prefix: string,
): string | undefined {
  const files = fs.readdirSync(startPath);
  for (const file of files) {
    const filePath = path.join(startPath, file);
    if (fs.statSync(filePath).isDirectory() && file.startsWith(prefix)) {
      return path.relative(startPath, filePath);
    }
  }
  return undefined;
}

/**
 * Finds the path to `stdlib.tact` in the `node_modules` of all the messed-up
 * directory structures generated by any imaginable npm garbage.
 *
 * XXX: Touching paths below is not only dangerous, it should be considered illegal.
 */
export function setTactStdlibPath(): string {
  const stdlibPathElements = ["@tact-lang", "compiler", "stdlib"];
  let distPathPrefix = __dirname.includes("/dist/")
    ? path.join("..", "..", "..", "..")
    : path.join("..", "..", "..");

  // pnpm (https://pnpm.io/) is another package manager which introduced a path
  // structure different from yarn/npm. This hack bypasses it.
  const pnpmDir = path.join(
    path.resolve(__dirname, distPathPrefix),
    "..",
    "..",
  );
  if (path.basename(pnpmDir).includes("pnpm")) {
    const mistiDir = findDirectoryPath(pnpmDir, "@nowarp+misti");
    if (mistiDir !== undefined) {
      distPathPrefix = path.join(
        distPathPrefix,
        "..",
        "..",
        mistiDir,
        "node_modules",
      );
    }
  }

  return path.resolve(__dirname, distPathPrefix, ...stdlibPathElements);
}

/**
 * Adds STDLIB_PATH_ARG to the list of arguments if not set.
 *
 * This is required to use Tact's stdlib from the `node_modules` of the current
 * blueprint project because it is not included in the `node_modules/@nowarp/misti`.
 */
function setStdlibPath(args: string[]): void {
  if (hasStdlibPath(args)) return;
  args.push(STDLIB_PATH_ARG);
  args.push(setTactStdlibPath());
}

export const misti: Runner = async (args: Args, ui: UIProvider) => {
  ui.write("⏳ Checking the project...\n");
  const argsStr = argsToStringList(args).slice(1);
  setStdlibPath(argsStr);
  const result = await runMistiCommand(argsStr);
  if (result.errorsFound === 0 || result.output === undefined) {
    if (result.error) {
      // They are already printed to stderr by the driver
      ui.write("⚠️ There are some problems executing Misti");
    } else {
      ui.write("✅ No errors found");
    }
  } else {
    ui.write(`❌ Misti found ${result.errorsFound} errors:\n${result.output}`);
  }
};
